#!/bin/bash
set -euo pipefail

# ===========================================================================
# autoclaude — Automated Claude Code runner
# See usage() below for details.
# ===========================================================================

VERSION="dev"
REPO_URL="https://github.com/evanisnor/autoclaude"

usage() {
    cat <<'USAGE'
autoclaude — Automated Claude Code runner

Runs Claude Code in headless mode to build a project. When usage limits
are hit, waits for the reset window and resumes automatically.

Prompt:
  By default, autoclaude looks for a prompt file at:
    autoclaude/prompt.md
    autoclaude/prompt.txt

  You can override this with:
    -p "prompt text"           Provide a prompt inline
    --prompt-file <file>       Use a custom prompt file

Usage:
  ./autoclaude                                     # Resume saved session, or start new
  ./autoclaude --new                               # Force a new session
  ./autoclaude -p "Build the login page"           # Use a text prompt
  ./autoclaude --prompt-file my-prompt.md          # Use a custom prompt file
  ./autoclaude --path-to-claude /path/to/claude    # Override claude binary location
  ./autoclaude --usage                             # Print this help text
USAGE
}

PROJECT_DIR="$PWD"
LOG_DIR="$PROJECT_DIR/.autoclaude"
LOG_FILE="$LOG_DIR/autoclaude.log"
SESSION_FILE="$LOG_DIR/session_id"
SESSION_EVENTS="$LOG_DIR/last_session.jsonl"
RUN_STATE="$LOG_DIR/run_state"

CLAUDE_BIN="${CLAUDE_BIN:-claude}"
MODEL="sonnet"

CONFIG_DIR="$PROJECT_DIR/autoclaude"

# ---------------------------------------------------------------------------
# Resolve the prompt: explicit text > explicit file > default file
# ---------------------------------------------------------------------------
resolve_prompt() {
    local prompt_text="${1:-}"
    local prompt_file="${2:-}"

    # If a text prompt was given directly, use it
    if [[ -n "$prompt_text" ]]; then
        echo "$prompt_text"
        return
    fi

    # If no file was given, fall back to defaults
    if [[ -z "$prompt_file" ]]; then
        for candidate in "$CONFIG_DIR/prompt.md" "$CONFIG_DIR/prompt.txt"; do
            if [[ -f "$candidate" ]]; then
                prompt_file="$candidate"
                break
            fi
        done
    fi

    if [[ -z "$prompt_file" || ! -f "$prompt_file" ]]; then
        echo "ERROR: No prompt provided. Use -p \"text\", --prompt-file <file>, or create $CONFIG_DIR/prompt.md" >&2
        echo >&2
        usage >&2
        exit 1
    fi

    cat "$prompt_file"
}

# ---------------------------------------------------------------------------
# Safety check: verify bypass permissions mode is not disabled
# ---------------------------------------------------------------------------
check_bypass_permissions_mode() {
    local settings_file="$PROJECT_DIR/.claude/settings.json"
    [[ ! -f "$settings_file" ]] && return 0

    local status
    status=$(jq -r '.permissions.disableBypassPermissionsMode // empty' "$settings_file" 2>/dev/null || true)
    if [[ "$status" == "disable" ]]; then
        echo "ERROR: .claude/settings.json has 'disableBypassPermissionsMode' set to \"disable\"." >&2
        echo "       autoclaude requires bypass permissions mode to be enabled in order to run" >&2
        echo "       Claude non-interactively with --dangerously-skip-permissions." >&2
        echo "       Remove the 'disableBypassPermissionsMode' setting to use autoclaude." >&2
        exit 1
    fi
}

# ===========================================================================
# Setup
# ===========================================================================

mkdir -p "$LOG_DIR"

log() {
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo "[$timestamp] $*" | tee -a "$LOG_FILE"
}

# ===========================================================================
# Event interpretation
# ===========================================================================

# Called for each stream-json event line. Logs human-readable summaries.
interpret_event() {
    local line="$1"
    local type
    type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null) || return 0
    [[ -z "$type" ]] && return 0

    case "$type" in
        assistant)
            while IFS= read -r tool_json; do
                [[ -z "$tool_json" ]] && continue
                local name input_summary
                name=$(echo "$tool_json" | jq -r '.name // ""' 2>/dev/null) || continue
                case "$name" in
                    Bash)       input_summary=$(echo "$tool_json" | jq -r '.input.description // .input.command // ""' 2>/dev/null | head -c 120) ;;
                    Read)       input_summary=$(echo "$tool_json" | jq -r '.input.file_path // ""' 2>/dev/null) ;;
                    Edit|Write) input_summary=$(echo "$tool_json" | jq -r '.input.file_path // ""' 2>/dev/null) ;;
                    Glob)       input_summary=$(echo "$tool_json" | jq -r '.input.pattern // ""' 2>/dev/null) ;;
                    Grep)       input_summary=$(echo "$tool_json" | jq -r '"\(.input.pattern // "") in \(.input.path // ".")"' 2>/dev/null) ;;
                    Task)       input_summary=$(echo "$tool_json" | jq -r '.input.description // ""' 2>/dev/null) ;;
                    TodoWrite)  input_summary="updating todo list" ;;
                    *)          input_summary=$(echo "$tool_json" | jq -r '.input | keys | join(", ")' 2>/dev/null) ;;
                esac
                log "  [$name] ${input_summary:0:120}"
            done < <(echo "$line" | jq -c '.message.content[]? | select(.type == "tool_use")' 2>/dev/null || true)
            ;;
        result)
            local result
            result=$(echo "$line" | jq -r '.result // ""' 2>/dev/null) || return 0
            [[ -n "$result" ]] && log "Result: ${result:0:300}"
            ;;
        rate_limit_event)
            local status
            status=$(echo "$line" | jq -r '.rate_limit_info.status // ""' 2>/dev/null) || return 0
            [[ "$status" == "rejected" ]] && log "Rate limit reached."
            ;;
    esac
}

# ===========================================================================
# Main
# ===========================================================================

main() {
    cat <<EOF
             _             _                 _        
  __ _ _   _| |_ ___   ___| | __ _ _   _  __| | ___   
 / _\` | | | | __/ _ \\ / __| |/ _\` | | | |/ _\` |/ _ \\  
| (_| | |_| | || (_) | (__| | (_| | |_| | (_| |  __/_ 
 \__,_|\__,_|\__\___/ \___|_|\__,_|\__,_|\__,_|\___(_) ${VERSION}
 ${REPO_URL}

EOF
    local force_new=false
    local prompt_text=""
    local prompt_file=""
    local path_to_claude=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --usage)              usage; exit 0 ;;
            --new)                force_new=true;                      shift ;;
            -p|--prompt)          prompt_text="${2:-}";               shift 2 ;;
            --prompt=*)           prompt_text="${1#*=}";              shift ;;
            --prompt-file)        prompt_file="${2:-}";               shift 2 ;;
            --prompt-file=*)      prompt_file="${1#*=}";              shift ;;
            --path-to-claude)     path_to_claude="${2:-}";            shift 2 ;;
            --path-to-claude=*)   path_to_claude="${1#*=}";           shift ;;
            *)                    shift ;;
        esac
    done

    if [[ -n "$prompt_text" && -n "$prompt_file" ]]; then
        echo "ERROR: Cannot use both -p/--prompt and --prompt-file. Pick one." >&2
        echo >&2
        usage >&2
        exit 1
    fi

    if [[ -n "$path_to_claude" ]]; then
        CLAUDE_BIN="$path_to_claude"
    fi

    if ! command -v "$CLAUDE_BIN" &>/dev/null && ! [[ -x "$CLAUDE_BIN" ]]; then
        if [[ -n "$path_to_claude" ]]; then
            echo "ERROR: Cannot find claude at '$CLAUDE_BIN'. Check that the path is correct." >&2
        else
            echo "ERROR: Cannot find claude on your PATH. Install Claude Code or use --path-to-claude to specify its location." >&2
        fi
        echo >&2
        usage >&2
        exit 1
    fi

    check_bypass_permissions_mode

    local saved_session=""
    [[ -f "$SESSION_FILE" ]] && saved_session="$(cat "$SESSION_FILE")"

    # Determine mode: resume saved session by default, or start new
    local mode="new"
    if [[ "$force_new" == true ]]; then
        mode="new"
        saved_session=""
        rm -f "$SESSION_FILE"
    elif [[ -n "$saved_session" ]]; then
        mode="resume"
    fi

    local display_prompt=""
    if [[ -n "$prompt_text" ]]; then
        display_prompt="(inline text)"
    elif [[ -n "$prompt_file" ]]; then
        display_prompt="$prompt_file"
    else
        for candidate in "$CONFIG_DIR/prompt.md" "$CONFIG_DIR/prompt.txt"; do
            if [[ -f "$candidate" ]]; then
                display_prompt="$candidate"
                break
            fi
        done
    fi

    log "============================================"
    log "autoclaude starting"
    log "  mode:       $mode"
    log "  prompt:     ${display_prompt:-(not found)}"
    log "  session ID: ${saved_session:-(none)}"
    log "  log:        $LOG_FILE"
    log "============================================"

    local PROMPT
    PROMPT="$(resolve_prompt "$prompt_text" "$prompt_file")"
    if [[ -n "$prompt_text" ]]; then
        log "Using inline prompt"
    elif [[ -n "$prompt_file" ]]; then
        log "Loaded prompt from $prompt_file"
    else
        log "Loaded prompt from default file"
    fi

    local -a base_cmd=(
        "$CLAUDE_BIN"
        -p "$PROMPT"
        --model "$MODEL"
        --dangerously-skip-permissions
        --output-format stream-json
        --verbose
    )

    # Set initial resume flag based on mode
    local resume_flag=""
    if [[ "$mode" == "resume" && -n "$saved_session" ]]; then
        resume_flag="--resume $saved_session"
        log "Resuming session: $saved_session"
    else
        log "Starting new session."
    fi

    while true; do
        # Build command with current resume flag
        local -a cmd=("${base_cmd[@]}")
        if [[ -n "$resume_flag" ]]; then
            read -ra resume_args <<< "$resume_flag"
            cmd+=("${resume_args[@]}")
        fi

        log "Running: $CLAUDE_BIN -p <prompt> --model $MODEL --dangerously-skip-permissions --output-format stream-json --verbose${resume_flag:+ $resume_flag}"

        > "$SESSION_EVENTS"
        > "$RUN_STATE"

        cd "$PROJECT_DIR"
        unset CLAUDECODE 2>/dev/null || true

        # Stream events line by line. Use set +e to capture exit code through
        # the pipeline — PIPESTATUS[0] gives claude's exit code after the pipe.
        local exit_code=0
        set +e
        "${cmd[@]}" 2>&1 | while IFS= read -r line; do
            echo "$line" >> "$SESSION_EVENTS"
            interpret_event "$line" 2>/dev/null || true

            local type
            type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null || true)

            case "$type" in
                result)
                    local sid
                    sid=$(echo "$line" | jq -r '.session_id // empty' 2>/dev/null || true)
                    [[ -n "$sid" ]] && echo "SESSION_ID=$sid" >> "$RUN_STATE"
                    ;;
                rate_limit_event)
                    local rl_status resets_at
                    rl_status=$(echo "$line" | jq -r '.rate_limit_info.status // ""' 2>/dev/null || true)
                    resets_at=$(echo "$line" | jq -r '.rate_limit_info.resetsAt // empty' 2>/dev/null || true)
                    [[ "$rl_status" == "rejected" && -n "$resets_at" ]] && echo "RESETS_AT=$resets_at" >> "$RUN_STATE"
                    ;;
            esac
        done
        exit_code=${PIPESTATUS[0]}
        set -e

        # Read state written by the stream processor
        local session_id="" resets_at=""
        if [[ -f "$RUN_STATE" ]]; then
            session_id=$(grep '^SESSION_ID=' "$RUN_STATE" 2>/dev/null | cut -d= -f2 | tail -1 || true)
            resets_at=$(grep '^RESETS_AT=' "$RUN_STATE" 2>/dev/null | cut -d= -f2 | tail -1 || true)
        fi

        if [[ -n "$session_id" ]]; then
            echo "$session_id" > "$SESSION_FILE"
            log "Session ID saved: $session_id"
        fi

        if [[ -n "$resets_at" ]]; then
            local now resume_at wait_seconds resume_human
            now=$(date +%s)
            resume_at=$(( resets_at + 120 ))
            wait_seconds=$(( resume_at - now ))
            resume_human="$(date -r "$resume_at" '+%Y-%m-%d %H:%M:%S')"

            if (( wait_seconds > 0 )); then
                log "Waiting until $resume_human for rate limit to reset..."
                sleep "$wait_seconds"
            fi

            log "Resuming..."
            if [[ -n "$session_id" ]]; then
                resume_flag="--resume $session_id"
            else
                resume_flag="--continue"
            fi
        elif [[ $exit_code -ne 0 ]]; then
            log "Claude exited with error (exit code: $exit_code). See $SESSION_EVENTS for details."
            exit 1
        else
            log "Claude exited cleanly."
            log "Session complete."
            break
        fi
    done

    log "============================================"
    log "autoclaude finished"
    log "============================================"
}

main "$@"
