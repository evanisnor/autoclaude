#!/bin/bash
set -euo pipefail

# ===========================================================================
# autoclaude — Automated Claude Code runner
# See usage() below for details.
# ===========================================================================

VERSION="dev"
REPO_URL="https://github.com/evanisnor/autoclaude"

PROJECT_DIR="$PWD"
STATE_DIR="$PROJECT_DIR/.autoclaude"
LOG_FILE="$STATE_DIR/autoclaude.log"
mkdir -p "$STATE_DIR"

DEBUG=false
UTC=false

# log [INFO|DEBUG] <message>
# Log level defaults to INFO. DEBUG lines are suppressed unless --debug is set.
# Timestamps use local time with UTC offset by default; set UTC=true for UTC.
log() {
    local level="INFO"
    if [[ "$1" == "INFO" || "$1" == "DEBUG" ]]; then
        level="$1"
        shift
    fi
    [[ "$level" == "DEBUG" && "$DEBUG" != true ]] && return 0
    local timestamp
    if [[ "$UTC" == true ]]; then
        timestamp="$(date -u '+%Y-%m-%d %H:%M:%SZ')"
    else
        timestamp="$(date '+%Y-%m-%d %H:%M:%S %z')"
    fi
    echo "[$timestamp] [$level] $*" | tee -a "$LOG_FILE"
}

# ===========================================================================
# Signal handling
# ===========================================================================
CAFFEINATE_PID=""

_cleanup() {
    trap - INT TERM
    [[ -n "${CAFFEINATE_PID:-}" ]] && kill "$CAFFEINATE_PID" 2>/dev/null || true
    exit 130
}
trap _cleanup INT TERM

usage() {
    cat <<'USAGE'
autoclaude — Automated Claude Code runner

Runs Claude Code in headless mode to build a project. When usage limits
are hit, waits for the reset window and resumes automatically.

Prompt:
  By default, autoclaude looks for a prompt file at:
    autoclaude/prompt.md
    autoclaude/prompt.txt

  You can override this with:
    -p "prompt text"           Provide a prompt inline
    --prompt-file <file>       Use a custom prompt file

Usage:
  ./autoclaude                                     # Resume saved session, or start new
  ./autoclaude --install-hook                      # Install the `new-session-on-todos-complete` hook
  ./autoclaude --new                               # Force a new session
  ./autoclaude -p "Build the login page"           # Use a text prompt
  ./autoclaude --prompt-file my-prompt.md          # Use a custom prompt file
  ./autoclaude --path-to-claude /path/to/claude    # Override claude binary location
  ./autoclaude --model opus                        # Override the model
  ./autoclaude --debug                             # Enable debug logging
  ./autoclaude --utc                               # Print log timestamps in UTC
  ./autoclaude --usage                             # Print this help text
USAGE
}

SESSION_FILE="$STATE_DIR/session_id"
SESSION_EVENTS="$STATE_DIR/last_session.jsonl"
RUN_STATE="$STATE_DIR/run_state"
PROMPT_HASH_FILE="$STATE_DIR/prompt_hash"

CLAUDE_BIN="${CLAUDE_BIN:-claude}"
MODEL="sonnet"

CONFIG_DIR="$PROJECT_DIR/autoclaude"
HOOK_SCRIPT_NAME="new-session-on-todos-complete.sh"


yellow=$'\033[33m'
red=$'\033[31m'
green=$'\033[32m'
reset=$'\033[0m'
bold=$'\033[1m'

# ---------------------------------------------------------------------------
# Resolve the prompt: explicit text > explicit file > default file
# ---------------------------------------------------------------------------
resolve_prompt() {
    local prompt_text="${1:-}"
    local prompt_file="${2:-}"

    # If a text prompt was given directly, use it
    if [[ -n "$prompt_text" ]]; then
        echo "$prompt_text"
        return
    fi

    # If no file was given, fall back to defaults
    if [[ -z "$prompt_file" ]]; then
        for candidate in "$CONFIG_DIR/prompt.md" "$CONFIG_DIR/prompt.txt"; do
            if [[ -f "$candidate" ]]; then
                prompt_file="$candidate"
                break
            fi
        done
    fi

    if [[ -z "$prompt_file" || ! -f "$prompt_file" ]]; then
        error "No prompt provided. Use -p \"text\", --prompt-file <file>, or create $CONFIG_DIR/prompt.md"
        usage >&2
        exit 1
    fi

    cat "$prompt_file"
}

# ---------------------------------------------------------------------------
# Safety check: verify bypass permissions mode is not disabled
# ---------------------------------------------------------------------------
check_bypass_permissions_mode() {
    local settings_file="$PROJECT_DIR/.claude/settings.json"
    [[ ! -f "$settings_file" ]] && return 0

    local status
    status=$(jq -r '.permissions.disableBypassPermissionsMode // empty' "$settings_file" 2>/dev/null || true)
    if [[ "$status" == "disable" ]]; then
        error " .claude/settings.json has 'disableBypassPermissionsMode' set to \"disable\".
       autoclaude requires bypass permissions mode to be enabled in order to run
       Claude non-interactively with --dangerously-skip-permissions.
       Remove the 'disableBypassPermissionsMode' setting to use autoclaude."
    fi
}

# ---------------------------------------------------------------------------
# Security check: warn if credential-protection deny rules are missing
# ---------------------------------------------------------------------------
check_credential_deny_rules() {
    local settings_file="$PROJECT_DIR/.claude/settings.json"

    # Each entry is "rule|path_to_check". The rule is only relevant if the
    # corresponding file or directory actually exists.
    local -a rule_path_pairs=(
        "Read(./.env)|$PROJECT_DIR/.env"
        "Read(./.env.*)|$PROJECT_DIR/.env.*"
        "Read(./secrets/**)|$PROJECT_DIR/secrets"
        "Read(~/.aws/**)|$HOME/.aws"
        "Read(~/.ssh/**)|$HOME/.ssh"
    )

    local -a applicable_rules=()
    for pair in "${rule_path_pairs[@]}"; do
        local rule="${pair%%|*}"
        local path="${pair##*|}"
        # Use glob expansion to check for .env.* matches
        local exists=false
        for f in $path; do
            [[ -e "$f" ]] && exists=true && break
        done
        [[ "$exists" == true ]] && applicable_rules+=("$rule")
    done

    [[ ${#applicable_rules[@]} -eq 0 ]] && return 0

    local -a missing_rules=()

    if [[ ! -f "$settings_file" ]]; then
        missing_rules=("${applicable_rules[@]}")
    else
        local deny_json
        deny_json=$(jq -r '(.permissions.deny // []) | .[]' "$settings_file" 2>/dev/null || true)
        for rule in "${applicable_rules[@]}"; do
            if ! grep -qxF "$rule" <<< "$deny_json"; then
                missing_rules+=("$rule")
            fi
        done
    fi

    if [[ ${#missing_rules[@]} -gt 0 ]]; then
        echo "" >&2
        banner "$yellow" "[!] Security Warning"
        echo "" >&2
        echo "  ${yellow}Your .claude/settings.json is missing deny rules that protect${reset}" >&2
        echo "  ${yellow}credential files from being read by Claude. It is strongly${reset}" >&2
        echo "  ${yellow}recommended to add the following rules:${reset}" >&2
        echo "" >&2
        for rule in "${missing_rules[@]}"; do
            echo "  ${yellow}  • \"$rule\"${reset}" >&2
        done
        echo "" >&2
        echo "  ${yellow}See ${REPO_URL}?tab=readme-ov-file#recommended-claudesettingsjson${reset}" >&2
        echo "" >&2
    fi
}

# ---------------------------------------------------------------------------
# Gitignore check: ensure .autoclaude is listed in .gitignore so session
# state and logs are not accidentally committed.
# ---------------------------------------------------------------------------
check_gitignore() {
    local gitignore_file="$PROJECT_DIR/.gitignore"
    local skip_signal="$STATE_DIR/skip_gitignore_check"

    # User previously chose to never be asked again.
    [[ -f "$skip_signal" ]] && return 0

    # Already present — nothing to do.
    if [[ -f "$gitignore_file" ]] && grep -qxF ".autoclaude" "$gitignore_file"; then
        return 0
    fi

    echo "" >&2
    banner "$yellow" ".autoclaude is not in your .gitignore

  The .autoclaude directory stores session state and logs.
  It should be excluded from version control to avoid
  accidentally committing session data."
    echo "" >&2
    echo "  ${yellow}Add '.autoclaude' to ${gitignore_file#"$PROJECT_DIR/"}?${reset}" >&2
    echo "" >&2
    echo "  ${bold}[y]${reset} Yes, add it now" >&2
    echo "  ${bold}[n]${reset} No, skip for now (will ask again next run)" >&2
    echo "  ${bold}[d]${reset} No, and don't ask again" >&2
    echo "" >&2

    local answer answer_lower
    read -r -p "  Choice [y/n/d]: " answer </dev/tty
    answer_lower="$(echo "$answer" | tr '[:upper:]' '[:lower:]')"

    case "$answer_lower" in
        y|yes)
            echo ".autoclaude" >> "$gitignore_file"
            log "Added .autoclaude to ${gitignore_file#"$PROJECT_DIR/"}"
            ;;
        d|don\'t|dont|never)
            touch "$skip_signal"
            log "Gitignore check suppressed. Remove $skip_signal to re-enable."
            ;;
        *)
            log DEBUG "Gitignore check skipped by user (will prompt again next run)."
            ;;
    esac
    echo "" >&2
}

# ---------------------------------------------------------------------------
# install_hook: write the new-session-on-todos-complete hook script and
# register it in .claude/settings.json using jq.
# ---------------------------------------------------------------------------
install_hook() {
    local hooks_dir="$PROJECT_DIR/.claude/hooks"
    local hook_file="$hooks_dir/$HOOK_SCRIPT_NAME"
    local settings_file="$PROJECT_DIR/.claude/settings.json"

    # Write the hook script
    mkdir -p "$hooks_dir"
    cat > "$hook_file" <<'HOOK_SCRIPT'
#!/usr/bin/env bash
# new-session-on-todos-complete.sh
#
# PostToolUse hook: fires after every TodoWrite call.
#
# Claude's built-in todo system is session-level work tracking — separate
# from your project's task backlog. Claude typically creates internal todos
# to organize progress toward one of your project tasks, then marks them
# completed as it goes.
#
# When Claude marks a todo completed, this hook signals autoclaude to start
# a NEW session after Claude exits, giving the next project task a full,
# clean context window instead of inheriting accumulated session history.

set -euo pipefail

INPUT=$(cat)

# TodoWrite tool_input shape: { todos: [{ id, content, status, priority }] }
# Only signal a new session when ALL todos are completed — Claude creates
# multiple todos per project task, so triggering on the first completion
# would restart the session mid-task. A fully-completed list means Claude
# has finished its current batch of work.
REMAINING=$(printf '%s' "$INPUT" | jq -r '
  [.tool_input.todos[]? | select(.status != "completed")] | length
' 2>/dev/null)

if [[ "$REMAINING" == "0" && -n "$REMAINING" ]]; then
  # Signal autoclaude to start a new session after this one ends.
  mkdir -p "$PWD/.autoclaude"
  touch "$PWD/.autoclaude/new_session_requested"

  # Ask Claude to stop so autoclaude can restart with a fresh context window.
  printf 'All todos completed. Exit your current turn now — autoclaude will automatically start a new session with a full context window for the next project task.\n'
fi
HOOK_SCRIPT
    chmod +x "$hook_file"
    log "Hook script written: ${hook_file#"$PROJECT_DIR/"}"

    # Upsert the hook registration into .claude/settings.json
    local tmp_file
    tmp_file=$(mktemp)

    local base_json="{}"
    [[ -f "$settings_file" ]] && base_json=$(cat "$settings_file")

    # Merge: remove any existing TodoWrite matcher entry, then append the new one.
    # Preserves all other settings and hook entries.
    printf '%s' "$base_json" | jq --arg hook_cmd ".claude/hooks/$HOOK_SCRIPT_NAME" '
      .hooks.PostToolUse = (
        ([(.hooks.PostToolUse // [])[] | select(.matcher != "TodoWrite")])
        + [{
            "matcher": "TodoWrite",
            "hooks": [{
              "type": "command",
              "command": $hook_cmd,
              "timeout": 5
            }]
          }]
      )
    ' > "$tmp_file"

    mkdir -p "$PROJECT_DIR/.claude"
    mv "$tmp_file" "$settings_file"
    log "Hook registered in: ${settings_file#"$PROJECT_DIR/"}"

    echo ""
    banner "$green" "Hook installed successfully
  script:   .claude/hooks/$HOOK_SCRIPT_NAME
  settings: .claude/settings.json

When all of Claude's todos are completed, autoclaude will
automatically start a new session for the next project task.

Run 'autoclaude' to start with automatic session management."
}

banner() {
    local color="${1}"
    shift
    local text="${*}"
    local inner_width=66
    local pad_width=$((inner_width - 2))
    local border
    border=$(printf '═%.0s' $(seq 1 $inner_width))

    echo "  ${color}╔${border}╗${reset}" >&2

    while IFS= read -r line; do
        # Word-wrap lines exceeding pad_width
        while (( ${#line} > pad_width )); do
            local chunk="${line:0:$pad_width}"
            # Break at the last space within chunk, or hard-break if none
            if [[ "$chunk" =~ ^(.*)[[:space:]][^[:space:]]*$ ]]; then
                local break_point=${#BASH_REMATCH[1]}
                printf "  ${color}║  %-${pad_width}s║${reset}\n" "${line:0:$break_point}" >&2
                line="${line:$((break_point + 1))}"
            else
                printf "  ${color}║  %-${pad_width}s║${reset}\n" "$chunk" >&2
                line="${line:$pad_width}"
            fi
        done
        printf "  ${color}║  %-${pad_width}s║${reset}\n" "$line" >&2
    done <<< "$text"

    echo "  ${color}╚${border}╝${reset}" >&2
}

error() {
    local exit_code=1

    # If first arg is an integer, use it as exit code
    if [[ "$1" =~ ^[0-9]+$ ]]; then
        exit_code="$1"
        shift
    fi

    echo >&2
    log "${red}${bold}ERROR${reset}: $*"
    echo >&2
    exit "$exit_code"
}

# Compute a SHA-256 hash of a file, returning just the hex digest.
prompt_file_hash() {
    shasum -a 256 "$1" | cut -d' ' -f1
}

# ===========================================================================
# Event interpretation
# ===========================================================================

# Called for each stream-json event line. Logs human-readable summaries.
interpret_event() {
    local line="$1"
    local type
    type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null) || return 0
    [[ -z "$type" ]] && return 0

    case "$type" in
        assistant)
            while IFS= read -r tool_json; do
                [[ -z "$tool_json" ]] && continue
                local name input_summary
                name=$(echo "$tool_json" | jq -r '.name // ""' 2>/dev/null) || continue
                case "$name" in
                    Bash)       input_summary=$(echo "$tool_json" | jq -r '.input.description // .input.command // ""' 2>/dev/null | head -c 120) ;;
                    Read)       input_summary=$(echo "$tool_json" | jq -r '.input.file_path // ""' 2>/dev/null) ;;
                    Edit|Write) input_summary=$(echo "$tool_json" | jq -r '.input.file_path // ""' 2>/dev/null) ;;
                    Glob)       input_summary=$(echo "$tool_json" | jq -r '.input.pattern // ""' 2>/dev/null) ;;
                    Grep)       input_summary=$(echo "$tool_json" | jq -r '"\(.input.pattern // "") in \(.input.path // ".")"' 2>/dev/null) ;;
                    Task)       input_summary=$(echo "$tool_json" | jq -r '.input.description // ""' 2>/dev/null) ;;
                    TodoWrite)  input_summary="updating todo list" ;;
                    *)          input_summary=$(echo "$tool_json" | jq -r '.input | keys | join(", ")' 2>/dev/null) ;;
                esac
                log "[$name] ${input_summary:0:120}"
            done < <(echo "$line" | jq -c '.message.content[]? | select(.type == "tool_use")' 2>/dev/null || true)
            ;;
        result)
            local result
            result=$(echo "$line" | jq -r '.result // ""' 2>/dev/null) || return 0
            [[ -n "$result" ]] && log "Result: ${result:0:300}"
            ;;
        rate_limit_event)
            local status
            status=$(echo "$line" | jq -r '.rate_limit_info.status // ""' 2>/dev/null) || return 0
            [[ "$status" == "rejected" ]] && log "Rate limit reached."
            ;;
    esac
}

# ===========================================================================
# Main
# ===========================================================================

main() {
    cat <<EOF
             _             _                 _        
  __ _ _   _| |_ ___   ___| | __ _ _   _  __| | ___   
 / _\` | | | | __/ _ \\ / __| |/ _\` | | | |/ _\` |/ _ \\  
| (_| | |_| | || (_) | (__| | (_| | |_| | (_| |  __/_ 
 \__,_|\__,_|\__\___/ \___|_|\__,_|\__,_|\__,_|\___(_) ${red}${VERSION}${reset}
 ${REPO_URL}

EOF
    local force_new=false
    local prompt_text=""
    local prompt_file=""
    local path_to_claude=""
    local model_override=""
    local do_install_hook=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --usage)              usage; exit 0 ;;
            --install-hook)       do_install_hook=true;               shift ;;
            --new)                force_new=true;                      shift ;;
            --debug)              DEBUG=true;                          shift ;;
            --utc)                UTC=true;                            shift ;;
            -p|--prompt)          prompt_text="${2:-}";               shift 2 ;;
            --prompt=*)           prompt_text="${1#*=}";              shift ;;
            --prompt-file)        prompt_file="${2:-}";               shift 2 ;;
            --prompt-file=*)      prompt_file="${1#*=}";              shift ;;
            --path-to-claude)     path_to_claude="${2:-}";            shift 2 ;;
            --path-to-claude=*)   path_to_claude="${1#*=}";           shift ;;
            --model)              model_override="${2:-}";            shift 2 ;;
            --model=*)            model_override="${1#*=}";           shift ;;
            *)                    shift ;;
        esac
    done

    if [[ "$do_install_hook" == true ]]; then
        install_hook
        exit 0
    fi

    if [[ -n "$prompt_text" && -n "$prompt_file" ]]; then
        error "Cannot use both -p/--prompt and --prompt-file. Pick one."
        usage >&2
        exit 1
    fi

    if [[ -n "$path_to_claude" ]]; then
        CLAUDE_BIN="$path_to_claude"
    fi

    if [[ -n "$model_override" ]]; then
        MODEL="$model_override"
    fi

    if ! command -v "$CLAUDE_BIN" &>/dev/null && ! [[ -x "$CLAUDE_BIN" ]]; then
        if [[ -n "$path_to_claude" ]]; then
            error "Cannot find claude at '$CLAUDE_BIN'. Check that the path is correct."
        else
            error "Cannot find claude on your PATH. Install Claude Code or use --path-to-claude to specify its location."
        fi
        usage >&2
        exit 1
    fi

    check_bypass_permissions_mode
    check_credential_deny_rules
    check_gitignore

    local saved_session=""
    [[ -f "$SESSION_FILE" ]] && saved_session="$(cat "$SESSION_FILE")"

    # Determine mode: resume saved session by default, or start new
    local mode="new"
    if [[ "$force_new" == true ]]; then
        mode="new"
        saved_session=""
        rm -f "$SESSION_FILE"
    elif [[ -n "$saved_session" ]]; then
        mode="resume"
    fi

    local display_prompt=""
    if [[ -n "$prompt_text" ]]; then
        display_prompt="(inline text)"
    elif [[ -n "$prompt_file" ]]; then
        display_prompt="${prompt_file#"$PROJECT_DIR/"}"
    else
        for candidate in "$CONFIG_DIR/prompt.md" "$CONFIG_DIR/prompt.txt"; do
            if [[ -f "$candidate" ]]; then
                display_prompt="${candidate#"$PROJECT_DIR/"}"
                break
            fi
        done
    fi

    banner "$green" "autoclaude starting
  mode:       $mode
  model:      $MODEL
  session ID: ${saved_session:-(none)}
  prompt:     ${display_prompt:-(not found)}
  log:        ${LOG_FILE#"$PROJECT_DIR/"}"

    # Resolve the prompt file path so we can watch it for changes across sessions.
    # Only set for file-based prompts; empty for inline -p text.
    local active_prompt_file=""
    if [[ -z "$prompt_text" ]]; then
        if [[ -n "$prompt_file" ]]; then
            active_prompt_file="$prompt_file"
        else
            for candidate in "$CONFIG_DIR/prompt.md" "$CONFIG_DIR/prompt.txt"; do
                if [[ -f "$candidate" ]]; then
                    active_prompt_file="$candidate"
                    break
                fi
            done
        fi
    fi

    local PROMPT
    PROMPT="$(resolve_prompt "$prompt_text" "$prompt_file")"
    if [[ -n "$prompt_text" ]]; then
        log "Using inline prompt"
    elif [[ -n "$prompt_file" ]]; then
        log "Loaded prompt from $prompt_file"
    else
        log "Loaded prompt from default file"
    fi

    # Save the initial hash so we can detect edits between resumed sessions.
    if [[ -n "$active_prompt_file" ]]; then
        prompt_file_hash "$active_prompt_file" > "$PROMPT_HASH_FILE"
    fi

    local -a base_cmd=(
        "$CLAUDE_BIN"
        -p "$PROMPT"
        --model "$MODEL"
        --dangerously-skip-permissions
        --output-format stream-json
        --verbose
    )

    # Set initial resume flag based on mode
    local resume_flag=""
    if [[ "$mode" == "resume" && -n "$saved_session" ]]; then
        resume_flag="--resume $saved_session"
        log "Resuming session: $saved_session"
    else
        log "Starting new session."
    fi

    while true; do
        # Reload prompt file if it changed since the last session.
        if [[ -n "$active_prompt_file" && -f "$PROMPT_HASH_FILE" ]]; then
            local current_hash stored_hash
            current_hash=$(prompt_file_hash "$active_prompt_file")
            stored_hash=$(cat "$PROMPT_HASH_FILE")
            if [[ "$current_hash" != "$stored_hash" ]]; then
                log "Prompt file changed, reloading: $active_prompt_file"
                PROMPT="$(cat "$active_prompt_file")"
                base_cmd=(
                    "$CLAUDE_BIN"
                    -p "$PROMPT"
                    --model "$MODEL"
                    --dangerously-skip-permissions
                    --output-format stream-json
                    --verbose
                )
                echo "$current_hash" > "$PROMPT_HASH_FILE"
            fi
        fi

        # Build command with current resume flag
        local -a cmd=("${base_cmd[@]}")
        if [[ -n "$resume_flag" ]]; then
            read -ra resume_args <<< "$resume_flag"
            cmd+=("${resume_args[@]}")
        fi

        log "Running: $CLAUDE_BIN -p <prompt> --model $MODEL --dangerously-skip-permissions --output-format stream-json --verbose${resume_flag:+ $resume_flag}"
        log DEBUG "Full command: ${cmd[*]}"

        > "$SESSION_EVENTS"
        > "$RUN_STATE"

        cd "$PROJECT_DIR"
        unset CLAUDECODE 2>/dev/null || true

        # Simple pipeline — claude runs as a foreground process group member.
        # SIGINT from ctrl+c reaches the whole group and fires the top-level trap.
        # PIPESTATUS[0] captures claude's exit code after the pipe.
        local exit_code=0
        set +e
        "${cmd[@]}" 2>&1 | while IFS= read -r line; do
            echo "$line" >> "$SESSION_EVENTS"
            interpret_event "$line" 2>/dev/null || true

            local type
            type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null || true)

            case "$type" in
                result)
                    local sid
                    sid=$(echo "$line" | jq -r '.session_id // empty' 2>/dev/null || true)
                    [[ -n "$sid" ]] && echo "SESSION_ID=$sid" >> "$RUN_STATE"
                    ;;
                rate_limit_event)
                    local rl_status resets_at
                    rl_status=$(echo "$line" | jq -r '.rate_limit_info.status // ""' 2>/dev/null || true)
                    resets_at=$(echo "$line" | jq -r '.rate_limit_info.resetsAt // empty' 2>/dev/null || true)
                    [[ "$rl_status" == "rejected" && -n "$resets_at" ]] && echo "RESETS_AT=$resets_at" >> "$RUN_STATE"
                    ;;
            esac
        done
        exit_code=${PIPESTATUS[0]}
        set -e
        log DEBUG "claude exited with code: $exit_code"

        # Claude (Node.js) sets the terminal to raw mode and may not restore it
        # on exit. In raw mode ctrl+c is just a byte — not a signal. Restore
        # cooked mode so SIGINT works for everything that follows.
        stty sane 2>/dev/null || stty isig echo icrnl 2>/dev/null || true

        # Re-arm the trap: bash 3.2 may clobber it after a pipeline.
        trap _cleanup INT TERM

        # Read state written by the stream processor
        local session_id="" resets_at=""
        if [[ -f "$RUN_STATE" ]]; then
            session_id=$(grep '^SESSION_ID=' "$RUN_STATE" 2>/dev/null | cut -d= -f2 | tail -1 || true)
            resets_at=$(grep '^RESETS_AT=' "$RUN_STATE" 2>/dev/null | cut -d= -f2 | tail -1 || true)
        fi

        if [[ -n "$session_id" ]]; then
            echo "$session_id" > "$SESSION_FILE"
            log "Session ID saved: $session_id"
        fi

        # Always log the last result event for diagnostics, regardless of exit path.
        if [[ -f "$SESSION_EVENTS" ]]; then
            local last_result_line
            last_result_line=$(grep -E '"type"\s*:\s*"result"' "$SESSION_EVENTS" | tail -1 || true)
            if [[ -n "$last_result_line" ]]; then
                local result_subtype result_is_error result_stop_reason
                result_subtype=$(echo "$last_result_line" | jq -r '.subtype // "(none)"' 2>/dev/null || echo "(parse error)")
                result_is_error=$(echo "$last_result_line" | jq -r '.is_error // "(none)"' 2>/dev/null || echo "(parse error)")
                result_stop_reason=$(echo "$last_result_line" | jq -r '.stop_reason // "(none)"' 2>/dev/null || echo "(parse error)")
                log DEBUG "[result] subtype=$result_subtype  is_error=$result_is_error  stop_reason=$result_stop_reason  exit_code=$exit_code"
                log DEBUG "[result] raw: ${last_result_line}"
            else
                log DEBUG "[result] no result event found in session events (exit_code=$exit_code)"
            fi
        fi

        if [[ -n "$resets_at" ]]; then
            local now resume_at wait_seconds resume_human
            now=$(date +%s)
            resume_at=$(( resets_at + 120 ))
            wait_seconds=$(( resume_at - now ))
            resume_human="$(date -r "$resume_at" '+%Y-%m-%d %H:%M:%S')"

            if (( wait_seconds > 0 )); then
                log "Waiting until $resume_human for rate limit to reset..."
                log DEBUG "Rate limit resets_at=$resets_at now=$(date +%s) wait_seconds=$wait_seconds resume_at=$resume_at"

                # caffeinate -i -w $$ prevents idle sleep and exits
                # automatically when this shell exits.
                if command -v caffeinate >/dev/null 2>&1; then
                    caffeinate -i -w $$ &
                    CAFFEINATE_PID=$!
                    log DEBUG "caffeinate started (PID: $CAFFEINATE_PID)"
                else
                    log DEBUG "caffeinate not available, skipping"
                fi

                # Use perl for the wait loop. After the claude pipeline bash 3.2
                # leaves SIGINT as SIG_IGN at the kernel level, so no bash trap
                # can fire. Perl receives SIGINT normally and forwards SIGTERM
                # to the parent bash process (SIGTERM is not affected by the
                # pipeline SIG_IGN issue).
                local bash_pid=$$
                log DEBUG "Starting perl sleep: ${wait_seconds}s until $resume_human (resume_at=$resume_at)"
                /usr/bin/perl -e '
                    my ($ppid, $resume_at) = @ARGV;
                    $SIG{INT} = sub { kill "TERM", $ppid; exit 130; };
                    while (1) {
                        my $now = time();
                        last if $now >= $resume_at;
                        my $step = ($resume_at - $now);
                        $step = 60 if $step > 60;
                        sleep($step);
                    }
                ' "$bash_pid" "$resume_at"
                log DEBUG "Perl sleep complete"

                if [[ -n "${CAFFEINATE_PID:-}" ]]; then
                    log DEBUG "Stopping caffeinate (PID: $CAFFEINATE_PID)"
                    kill "$CAFFEINATE_PID" 2>/dev/null || true
                fi
                CAFFEINATE_PID=""
            fi

            log "Resuming..."
            if [[ -n "$session_id" ]]; then
                resume_flag="--resume $session_id"
            else
                resume_flag="--continue"
            fi
        elif [[ $exit_code -ne 0 ]]; then
            error "$exit_code" "Claude exited with error (exit code: $exit_code). See $SESSION_EVENTS for details."
        elif [[ -f "$STATE_DIR/new_session_requested" ]]; then
            log "Claude exited cleanly."
            rm -f "$STATE_DIR/new_session_requested"
            rm -f "$SESSION_FILE"
            resume_flag=""
            echo ""
            banner "$green" "Task complete — starting new session with fresh context."
            echo ""
        else
            log "Claude exited cleanly."
            log "Session complete."
            break
        fi
    done

    banner "$green" "autoclaude finished"
}

main "$@"
